##### Что такое интерпретируемый язык? Как он работает в Python?
Язык, у которого исходный код превращается в машинный без предварительной компиляции построчно, прямо во время выполнения. При запуске программы Питон читает код, проверяет форматирование и синтаксис. После чего строится синтаксическое дерево, промежуточный код и все это переводится в байт-код (независимая от платформы низкоуровневая запись программы).
Компилятор:
- проверяет синтаксис, отступы, скобки и прочее
- не проверяет математические косяки и типизацию
- складывает байт-код .pyc в __pycache__
PVM (python virtual machine):
- байт-код не является в чистом виде машинным кодом, лишь внутреннее представление языка
- это дополнительное преобразование делает язык быстрее, потому что базовые вещи обрабатывает компилятор, и интерпретатору не нужно по полной обрабатывать исходный код
Таким образом Питон по производительности находится между обычными интерпретаторами вроде PHP и компилируемыми языками типа C++
##### Что такое статическая и динамическая типизация и в чем это проявляется в Python?
Статическая типизация проверяется прямо на этапе компиляции, тогда как динамическая - нет. Все, что плавает как утка и крякает как утка - и есть утка.
##### Сравнение значений и ссылок
`==` сравнивает значения объектов, тогда как `is` сравнивает, указывают ли объекты на одну и ту же область в памяти. В большинстве случаев с простыми объектами (int, float и т.д.) показывают одно и то же. Но с более сложными структурами все интереснее:
```python
>>> mas1 = [1, [2], 3]
>>> mas2 = deepcopy(mas1)
>>> mas3 = [1, [2], 3]
>>> print(mas1 == mas2, mas1 == mas3)
True True
>>> print(mas1 is mas2, mas1 is mas3)
False False
```
##### Что такое list comprehensions?
Списковые выражения. Работают как своего рода синтаксический сахар для создания списков по итерируемым объектам. Так же с помощью них можно делать фильтрацию
```python
new_list = [a for a in old_list if a % 2 == 0]
```
##### Какие типы данных в Python вам известны? Как реализован под капотом питоновский список? Чем кортеж отличается от списка? В каких случаях лучше использовать кортеж, а в каких - список?
Изменяемые: list, set, dict
Неизменяемые: bool, int, float, str, frozenset
**list** работает как динамический массив (он реализован на C). Память выделяется заранее, чтобы каждый раз не менять длину списка (по вот такой последовательности: 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, …). Сжимается, если количество элементов меньше половины выделенной памяти.
У кортежа память выделяется один раз и не меняется, а в целом - и то, и другое хранится как массив по порядку в памяти.
##### Как вы объясните человеку, что такое множество?
Неупорядоченное множество элементов, каждый из которых встречается ровно один раз.
##### Что такое словари и как они работают? Как работают типы данных хэшмап, связанный список, двусвязный список, массив?
Словари - набор элементов типа "ключ-значение".
Хэшмап / словарь - бакеты и по хешу суются значения (при условии, что бакетов меньше, чем значений, сложность будет O(1), иначе O(n)). Все остальное должен знать.
##### Что такое О (о-большое)? Зачем и как используется? Какая сложность вставки, извлечения, поиска элементов в словаре и списке?
Функция для оценки асимптотической сложности. Удаление и вставка - смотря что там с заполнением. Поиск по словарю - O(1) в хорошем исходе, у списка всегда придется смотреть все.
##### Что такое функции и зачем они нужны? Что такое замыкание? Какие бывают аргументы у функций? Как их передавать? Что означает * в сигнатуре аргументов функции?
Вынесенные участки кода. Чтобы сделать проще переиспользование и тестирование написанного кода. Именованные и неименованные. * - раскрытие итерируемого объекта, ** - раскрытие словаря.
##### Какие бывают области видимости и как они работают?
1. сначала поиск идет локально (внутри своей функции) - Local
2. потом во внешней функции - Enclosing
3. потом в глобальной области - Global
4. потом в built-in - Built-In
`global a` - меняет значение переменной из глобальной области видимости
`nonlocal a` - внешняя область видимости (enclosing)
_Замыкание_ - когда используем внутри функции аргументы из внешней функции
##### Что такое None?
Переменная, которая не содержит никакого значения.
##### TDD / DDD
Test Driven Development - сначала пишутся тесты, а затем функционал, который будет им удовлетворять
Domain Driven Development - предметно-ориентированное проектирование, сводится к созданию программных абстракций, которые будут называться моделями предметных областей
##### Mock
Фиктивная реализация интерфейса для тестирования. Например - FactoryBoy (создает подставные объекты)
##### MRO
Method Resolution Order - то, в каком порядке идет поиск метода в родительских классах.
Left -> Right -> Top -> Again
##### Что такое исключения? Какие они бывают? Как их использовать?
События, которые влекут за собой ошибку или неправильное выполнение программы.
- BaseException - всему голова
- системные - SystemExit, KeyboardInterrupt, GeneratorExit
- обыкновенные - StopIteration, ArithmeticError, AssertionError, AttributeError, ImportError
```python
try:
	# пробуем выполнить
except (ValueError, TyperError):
	# поймали какую-то ошибку
except Exception:
	# поймали какую-то другую ошибку
else:
	# не поймали ошибку
finally:
	# выполняем что-то независимо от того, поймали ошибку или нет
```
##### Что такое ООП? На каких концепциях стоит ООП?
Объектно ориентированное программирование - когда все в коде представляется в виде объектов и взаимоотношений между ними.
- Абстракция - использование только тех характеристик объекта, которые с точностью определяют его. Нужно представить объект минимальным набором полей и методов, при этом с достаточной точностью для решаемой задачи.
- Инкапсуляция - ограничение доступа к атрибутам класса извне (_ - protected и __ - private)
	```python
	class A:
	    def _private(self): # from class or from inherited class
	        print("Это приватный метод!")
	    def __private(self): # from class only, but a._A__private()
		    ...
	```
- Наследование - новые класс может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использования кода. Так же эти методы могут быть переопределены для дочерних классов.
	```python
	class A:
		def a():
			return "a"
		def b():
			return "b"
	class B(A):
		def b():
			return "bb"
	```
- Полиморфизм - единый интерфейс обращения без необходимости знать, как он работает. То есть одинаковые функции у разных классов, из-за которых с ними можно работать одинаково. То есть два класса, работают примерно одинаково, но не наследуются от одного, тогда как в переопределении именно наследование позволяет это сделать
	```python
	class Cat:
		def make_sound():
			return "meow"
	class Dog:
		def make_sound():
			return "wuff"
	```
##### Принципы SOLID.
- _Single Responsibility Principle -_ принцип единственной ответственности (один класс должен отвечать только за одну работу, не должно существовать “супер классов”)
- _Open-Closed Principle -_ сущности программы должны быть открыты для расширения, но закрыты для изменения. Т.е. класс должен быть определен достаточно, чтобы делать то, что он должен. Добавления любых других методов должно быть реализовано через наследование, не трогая оригинальный класс
- _Liskov Substitution Principle -_ принцип подстановки Барбары Лисков (подтипы должны без боли заменять свои родительские типы). По-другому - “сильный поведенческий тип”. Т.е. дочерние классы не должны сужать функционал родительских.
- _Interface Segregation Principle -_ принцип разделения интерфейса (давать в нужных местах только нужные интерфейсы, то есть минимально необходимый функционал). Так называемый “ролевой подход”. Пример: вместо абстрактного класса, который может делать все (не реализовано правда), лучше сделать несколько маленьких абстрактных
- _Dependency Inversion Principle -_ принцип инверсии зависимостей
	- модуль высокого уровня не должен зависеть от модулей низкого уровня: и то, и другое должно зависеть от абстракций
	- абстракции не должны зависеть от деталей реализации: детали реализации должны зависеть от абстракций
	- т.е. приложение должно строится на бизнес-схемах и не должны зависеть от реализации доступа к базе данных и прочего
##### Что такое staticmethod, classmethod, slots?
```python
class Person:
    __slots__ = ["name"] # ограничение на атрибуты объекта
    work_place: str = "My work place"

    def __init__(self, name: str) -> None:
        self.name = name

    def say_hello(self) -> None: # можно вызвать только из объекта
        print(f"Hello, my name is {self.name}")

    @classmethod
    def print_work_place(cls) -> None: # можно вызвать и из объекта, и из класса
        print(f"{cls.work_place}")
		
	@staticmethod
    def get_some(): # не имеет доступа ни к объекту, ни к классу, просто удобно держать здесь
        print("I'm statuc method")

p = Person()
print(Person.__dict__) # все атрибуты класса
print(p.__dict__) # все атрибуты объекта, т.е. конкретного экзмепляра
```
##### Что такое магические методы и за что они отвечают?
__ - дандер методы, помогают реализовать параметрический полиморфизм и перегружать методы
##### Что такое конструктор объектов в Python и из чего он состоит и как работает? Почему в методе **init** есть аргумент self?
Метод **new**() вызывается при создании нового экземпляра класса. Он отвечает за выделение памяти под новый объект и возвращает этот объект. **new**() является статическим методом и должен возвращать экземпляр класса.
С другой стороны, метод **init**() вызывается после **new**(), когда объект уже создан. Он отвечает за инициализацию этого объекта, то есть задаёт начальные значения его атрибутов. И именно поэтому у него внутри уже есть self.
##### Абстрактные классы
Своего рода интерфейсы в Python, т.е. то, что обязательно должно быть определено в дочерних классах. Интерфейс - методы, которые могут быть у совершенно разных классов. Абстрактные же классы объединяют общие классы + могут иметь реализованные методы.
```python
import abc

class Animal(abc.ABC):
    @abc.abstractmethod
    def run():
        raise NotImplemented
    
class Cat(Animal):
    def run():
        print("Cat is running!")

# a = Animal() # error, method not implemented
c = Cat()
c.run()
```
##### Что такое менеджер контекста, зачем он нужен?
Позволяет использовать какой-то объект внутри своего контекста, чаще всего, файлы. То есть файл открывается при использовании with и закрывается при выходе из него, что облегчает работу, потому что при ошибке и других случаях файл автоматически закроется.
```python
class ContextManager:
    def __enter__(self):
        self.start_time = datetime.datetime.now()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end_time = datetime.datetime.now()
        print(self.end_time - self.start_time)

if __name__ == "__main__":
    with ContextManager() as cm:
        time.sleep(2)
```
##### Что такое GIL и как он работает?
GIL - это своего рода блокировка, позволяющая только одному потоку использовать интерпретатор питона.
Какую же проблемы решает GIL? В питоне освобождение памяти происходит по подсчету ссылок на объект: если на объект счетчик становится равным 0, то его память высвобождается. Проблема в том, что в многопоточном управлении несколько потоков могут увеличивать или уменьшать количество ссылок, из-за чего переменная, необходимая в одном потоке, может быть удалена в другом.
##### Что такое сборщик мусора и как он работает? Как работает resolve циклических ссылок сборщиком мусора?
Сборщик мусора автоматически освобождает память, которая больше не используется. Он определяет, что память больше не используется, если на объект нет ссылок. Таким образом, чтобы освободить память, занимаемую объектом, достаточно удалить все ссылки на него.
Обычный сборщик мусора простой, и не умеет определять циклические ссылки. В таком случае подключается GC. Циклические ссылки могут появляться только в контейнерных объектах: списки, словари и прочее, и именно за такими объектами следит GC.
##### Что такое потоки и процессы? Чем отличается поток от процесса?
Процессы служат для запуска и управления программами, тогда как потоки служат для эффективного использования ресурсов и параллельного выполнения задач в рамках одного процесса.
##### Что такое системный вызов fork?
Функция fork модуля os создает клон текущего процесса как дочерний процесс. Возвращает 0 в дочернем процессе и идентификатор дочернего процесса в родительском элементе. Если возникает ошибка, то возникает исключение OSError.
##### Какие существуют способы синхронизации процессов и потоков?
- локи (acquire и release) -  блокировка для выполнения только одного потока
- семафоры - несколько потоков могут одновременно получать доступ (счетчик)
##### Как передавать информацию из одного процесса в другой?
```python
from multiprocessing import Process, Queue

def f(q):
    q.put([42, None, 'hello'])

if __name__ == '__main__':
    q = Queue()
    p = Process(target=f, args=(q,))
    p.start()
    print(q.get())    # prints "[42, None, 'hello']"
    p.join()
```
##### Что такое эффект гонок? Как с ним бороться?
race condition - неправильное проектирование многопоточной программы, когда результат зависит от того, в каком порядке потоки выполнились. Например, когда два потока пытаются одновременно получить доступ к одной переменной. Можно использовать блокировки
##### Что такое вытесняющая многозадачность?
То, как работают потоки в Питоне. Сразу несколько интерпретаторов быть не может, поэтому система сама переключает управление между потоками.
##### Что такое асинхронность? Что такое event loop и как он работает?
Концепция, когда результат выполнения функции доступен не сразу, а только по прохождении некоторого количества времени. Т.е. удобен тогда, когда функции постоянно работают с I/O задачами.
Event loop - сердце асинхронного приложения, он выполняет асинхронные функции, выполняет переключения между ожиданиями и многое другое. Рядовому разрабу с ним работать не нужно, только тем, кто пишет библиотеки под язык.
##### Сколько потоков и процессов работает во время асинхронного выполнения кода?
Всего один поток, внутри которого происходит переключение между задачами.
##### Способы использования параллельного / асинхронного кода? В чём отличие асинхронности от многопоточности? В каких задачах использовать асинхронность необходимо? В каких бессмысленно?
`multithreading` - в момент времени только один поток будет выполняться из-за GIL, но будет видимость многопоточности из-за быстрых переключений и I/O
`async/await` - корутины (функции), которые могут работать асинхронно. Если какая-то функция ждет входа или IO-операцию, то eventpool ищет другой код, который в это время можно выполнить
- `async def` - cоздание корутины, т.е. функции, которую можно приостановить
- `async / await` - синтаксический сахар для вызова и ожидания выполнения функции
Бесполезно использовать, если функции ничего не ожидают, то есть просто выполняют код под ряд (например, математические вычисления)
`multiprocessing` - когда каждому процессу выдается свой интерпретатор, но эти процессы не должны быть связаны
##### Что такое корутины, таски и футуры и чем друг от друга отличаются?
Coroutine - сопрограмма, которая написана в специальном синтаксисе (то есть генератор, которые может принимать и возвращать значения наружу)
Future - подобие Promise из JS. Объект, который заверяет, что результат можно будет получить тогда, когда операнд выполнится
Task - специальный объект, который создает Future, чтобы выполнить код в гоночном режиме
##### Что означает ключевое слово await?
Ожидание результата асинхронной функции
##### Как работает gather, wait_for?
`asyncio.gather(* tasks)` - асинхронно выполнит все переденные таски
`asyncio.wait_for(awaitable, timeout)` - если передана корутина, то автоматически она станет таской и будет выполнятся, пока не пройдет время timeout в секундах
##### Рекурсия и итерации
Рекурсивный процесс - это процесс с отложенным вычислением. Т.е. сначала он дойдет до низу, пока уже не сможет идти дальше, сохраняя при этом весь стек, и уже после этого пойдет наверх, параллельно освобождая стек и проводя вычисления.
Итеративный же процесс не нуждается в выделении памяти вне вызова функции, т.е. все выполняется в одном, явно сохраняя свой “стек”.
```python
def calc_fib(n: int) -> int:
	if n == 1 or n == 2:
		return 1
	return calc_fib(n - 1) + calc_fib(n - 2)
```
##### Декораторы
Обертка над функцией. Позволяют изменить поведение функции не изменяя ее саму.
```python
import json
cache_dict = dict()

def cache(func):
    def wrapper(*args, **kwargs):
        key = json.dumps(f"{args}{kwargs}")
        if key not in cache_dict:
            print("calculating")
            cache_dict[key] = func(*args, **kwargs)
        return cache_dict[key]
    return wrapper

def sleep(seconds: int = 2):
    def _sleep(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            time.sleep(seconds)
            func(*args, **kwargs)

        return wrapper

    return _sleep
```
##### Для чего нужны модули и пакеты?
Модуль - `.py` файлы. Пакеты - иерархические системы директорий, содержащие модули.
Простота (работа только над одним отдельным функционалом). Удобство обслуживания (low coupling - меньше связанности между отдельными частями приложения). Возможность повторного использования. Разметка (отдельные пространства имен, благодаря чему не будет путаницы о происхождении функций).
##### Копирование объектов
В python ‘=’ не копирует объекты, а создает связь между переменной в памяти и названием. Для копирования нужно использовать встроенные функции:
`from copy import copy, deepcopy`
- shallow copy - побитовая копия объекта. Если объект содержит другие объекты внутри, то копируются их ссылки, что не есть хорошо
- deep copy - рекурсивно копирует все объекты (в том числе и вложенные)
##### Итераторы и генераторы
Iterable - класс, у которого есть **iter** (по которому можно пройтись, то есть из него можно сделать итератор)
Iterator - класс, у которого есть **next** (тот, кто делает реальный проход, сам же может быть Iterable)
Генераторы - почти то же самое, только они сохраняют весь контекст функции
```python
class Iterator: # итератор (генератор), который сам генерирует последовательность
    def __init__(self, num):
        self.num = num
        self.idx = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.idx += 1
        if self.idx < self.num:
            return self.idx
        raise StopIteration

class Iterable: # итерируемый объект, из которого можно сделать итератор
    def __init__(self):
        self.seq = [1, 2, 3, 4]

    def __iter__(self):
        return self.seq.__iter__()

i = Iterable()
iterator = iter(i)
print(next(iterator))

def generate(): # сопрограмма
    k = 0
    while k < 10:
        i, j = (yield)
        print(i + j)
        k += 1

g = generate()
g.send(None)
g.send((1, 1))
```